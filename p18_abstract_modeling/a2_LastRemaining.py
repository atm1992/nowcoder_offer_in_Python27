# -*- coding: UTF-8 -*-
"""
孩子们的游戏(圆圈中最后剩下的数)。
每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。
其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。
每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,
继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。
请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)
如果没有小朋友，请返回-1

解题思路：约瑟夫环。圆圈长度为n的解可看作长度为n-1的解加上报数的长度m。因为是圆圈，所以最后要对n取余。
找数学规律：
第一步，n个人的编号为：0、1、2、……、n-2、n-1。最后剩下的数字记为f(n,m)
第二步，删除编号m-1，若m-1小于n，则为m-1，否则为(m-1)%n。令k = (m-1)%n，则n-1个人的编号为：0、1、……、k-1、k+1、……、n-1
第三步，开始报数的编号变为了k+1，即 k+1、……、n-1、0、1、……、k-1。最后剩下的数字记为f'(n-1,m)，因为最后剩下的是一个确定值(虽然未知)，所以f'(n-1,m)=f(n,m)
第四步，将 k+1、……、n-1、0、1、……、k-1 映射为 0~n-2，即：
k+1、k+2、……、n-1、0、1、……、k-1
0、1、……、n-1-(k+1)、n-k-1、n-k、……、n-2
上一行编号映射为下一行编号的公式为：p(x) = (x-k-1)%n
下一行编号映射为上一行编号的公式为：p'(x) = (x+k+1)%n
第五步，由于n-1个人的编号使用p(x)映射后，变成了0、1、……、n-1-(k+1)、n-k-1、n-k、……、n-2，这与0、1、2、……、n-2、n-1具有相同的形式(都从0开始升序)，
因此最后剩下的数字此时可记为f(n-1,m)。由上可知，对于长度为n-1的序列中最后剩下的数字而言，映射前记为f'(n-1,m)；映射后记为f(n-1,m)。
代入映射规则，f'(n-1,m) = p'(f(n-1,m)) = [f(n-1,m)+k+1]%n，然后代入k = (m-1)%n 、f'(n-1,m) = f(n,m)，
得到递推公式：f(n,m) = f'(n-1,m) = [f(n-1,m)+m]%n

对于函数f(n,m)的说明：      # 固定m为一个确定值
对于长度为n的序列，编号为：0、1、2、……、n-2、n-1，该序列最后剩下的数字为f(n,m)
对于长度为n-1的序列，编号为：0、1、2、……、n-2，该序列最后剩下的数字为f(n-1,m)
……
对于长度为2的序列，编号为：0、1，该序列最后剩下的数字为f(2,m)
对于长度为1的序列，编号为：0，该序列最后剩下的数字为f(1,m)，即 f(1,m)只能等于0
"""


class Solution1:
    # 使用循环来模拟游戏规则
    def LastRemaining_Solution(self, n, m):
        if not n or n < 1 or not m or m < 1:
            return -1
        # 保存着n个元素的值，也就是n个小朋友的名字或编号
        con = range(n)
        start = 0
        name = -1
        while con:
            # 第m-1个小朋友处于n中的第k个位置
            k = (start + m - 1) % n
            # name为第k个元素的值，也就是第m-1个小朋友的名字
            name = con.pop(k)
            # 圆圈长度减去1
            n -= 1
            # start变为从k开始，因为原来的第k个元素pop掉了，所以原来的第k+1个元素移动到了第k个位置
            start = k
        # 退出上述循环时，con为空，最后一个被pop掉的元素值为name
        return name


class Solution2:
    # 根据数学规律来递推结果
    def LastRemaining_Solution(self, n, m):
        if not n or n < 1 or not m or m < 1:
            return -1
        # 长度为1的序列，最后剩下的数字只能为0
        last = 0
        # 序列长度从2逐渐增加到n
        for i in range(2, n + 1):
            last = (last + m) % i
        return last
